// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rapid.proto

/*
	Package remoting is a generated protocol buffer package.

	It is generated from these files:
		rapid.proto

	It has these top-level messages:
		NodeId
		PreJoinMessage
		JoinMessage
		JoinResponse
		BatchedLinkUpdateMessage
		LinkUpdateMessage
		Response
		ConsensusProposal
		ConsensusProposalResponse
		Metadata
		ProbeMessage
		ProbeResponse
*/
package remoting

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type JoinStatusCode int32

const (
	JoinStatusCode_HOSTNAME_ALREADY_IN_RING JoinStatusCode = 0
	JoinStatusCode_UUID_ALREADY_IN_RING     JoinStatusCode = 1
	JoinStatusCode_SAFE_TO_JOIN             JoinStatusCode = 2
	JoinStatusCode_CONFIG_CHANGED           JoinStatusCode = 3
	JoinStatusCode_MEMBERSHIP_REJECTED      JoinStatusCode = 4
)

var JoinStatusCode_name = map[int32]string{
	0: "HOSTNAME_ALREADY_IN_RING",
	1: "UUID_ALREADY_IN_RING",
	2: "SAFE_TO_JOIN",
	3: "CONFIG_CHANGED",
	4: "MEMBERSHIP_REJECTED",
}
var JoinStatusCode_value = map[string]int32{
	"HOSTNAME_ALREADY_IN_RING": 0,
	"UUID_ALREADY_IN_RING":     1,
	"SAFE_TO_JOIN":             2,
	"CONFIG_CHANGED":           3,
	"MEMBERSHIP_REJECTED":      4,
}

func (x JoinStatusCode) String() string {
	return proto.EnumName(JoinStatusCode_name, int32(x))
}
func (JoinStatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{0} }

type LinkStatus int32

const (
	LinkStatus_UP   LinkStatus = 0
	LinkStatus_DOWN LinkStatus = 1
)

var LinkStatus_name = map[int32]string{
	0: "UP",
	1: "DOWN",
}
var LinkStatus_value = map[string]int32{
	"UP":   0,
	"DOWN": 1,
}

func (x LinkStatus) String() string {
	return proto.EnumName(LinkStatus_name, int32(x))
}
func (LinkStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{1} }

type NodeStatus int32

const (
	NodeStatus_OK            NodeStatus = 0
	NodeStatus_BOOTSTRAPPING NodeStatus = 1
)

var NodeStatus_name = map[int32]string{
	0: "OK",
	1: "BOOTSTRAPPING",
}
var NodeStatus_value = map[string]int32{
	"OK":            0,
	"BOOTSTRAPPING": 1,
}

func (x NodeStatus) String() string {
	return proto.EnumName(NodeStatus_name, int32(x))
}
func (NodeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{2} }

type NodeId struct {
	High int64 `protobuf:"varint,1,opt,name=high,proto3" json:"high,omitempty"`
	Low  int64 `protobuf:"varint,2,opt,name=low,proto3" json:"low,omitempty"`
}

func (m *NodeId) Reset()                    { *m = NodeId{} }
func (m *NodeId) String() string            { return proto.CompactTextString(m) }
func (*NodeId) ProtoMessage()               {}
func (*NodeId) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{0} }

func (m *NodeId) GetHigh() int64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *NodeId) GetLow() int64 {
	if m != nil {
		return m.Low
	}
	return 0
}

// TODO: JoinMessage and JoinResponse are overloaded because they are being used for phase 1 and 2 of the bootstrap.
type PreJoinMessage struct {
	Sender          string  `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	NodeId          *NodeId `protobuf:"bytes,2,opt,name=nodeId" json:"nodeId,omitempty"`
	RingNumber      []int32 `protobuf:"varint,3,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	ConfigurationId int64   `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
}

func (m *PreJoinMessage) Reset()                    { *m = PreJoinMessage{} }
func (m *PreJoinMessage) String() string            { return proto.CompactTextString(m) }
func (*PreJoinMessage) ProtoMessage()               {}
func (*PreJoinMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{1} }

func (m *PreJoinMessage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *PreJoinMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *PreJoinMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *PreJoinMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

type JoinMessage struct {
	Sender          string    `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	NodeId          *NodeId   `protobuf:"bytes,2,opt,name=nodeId" json:"nodeId,omitempty"`
	RingNumber      []int32   `protobuf:"varint,3,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	ConfigurationId int64     `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Metadata        *Metadata `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *JoinMessage) Reset()                    { *m = JoinMessage{} }
func (m *JoinMessage) String() string            { return proto.CompactTextString(m) }
func (*JoinMessage) ProtoMessage()               {}
func (*JoinMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{2} }

func (m *JoinMessage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *JoinMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *JoinMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *JoinMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *JoinMessage) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type JoinResponse struct {
	Sender          string               `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	StatusCode      JoinStatusCode       `protobuf:"varint,2,opt,name=statusCode,proto3,enum=remoting.JoinStatusCode" json:"statusCode,omitempty"`
	ConfigurationId int64                `protobuf:"varint,3,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Hosts           []string             `protobuf:"bytes,4,rep,name=hosts" json:"hosts,omitempty"`
	Identifiers     []*NodeId            `protobuf:"bytes,5,rep,name=identifiers" json:"identifiers,omitempty"`
	ClusterMetadata map[string]*Metadata `protobuf:"bytes,6,rep,name=clusterMetadata" json:"clusterMetadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *JoinResponse) Reset()                    { *m = JoinResponse{} }
func (m *JoinResponse) String() string            { return proto.CompactTextString(m) }
func (*JoinResponse) ProtoMessage()               {}
func (*JoinResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{3} }

func (m *JoinResponse) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *JoinResponse) GetStatusCode() JoinStatusCode {
	if m != nil {
		return m.StatusCode
	}
	return JoinStatusCode_HOSTNAME_ALREADY_IN_RING
}

func (m *JoinResponse) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *JoinResponse) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *JoinResponse) GetIdentifiers() []*NodeId {
	if m != nil {
		return m.Identifiers
	}
	return nil
}

func (m *JoinResponse) GetClusterMetadata() map[string]*Metadata {
	if m != nil {
		return m.ClusterMetadata
	}
	return nil
}

type BatchedLinkUpdateMessage struct {
	Sender   string               `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Messages []*LinkUpdateMessage `protobuf:"bytes,3,rep,name=messages" json:"messages,omitempty"`
}

func (m *BatchedLinkUpdateMessage) Reset()                    { *m = BatchedLinkUpdateMessage{} }
func (m *BatchedLinkUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*BatchedLinkUpdateMessage) ProtoMessage()               {}
func (*BatchedLinkUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{4} }

func (m *BatchedLinkUpdateMessage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *BatchedLinkUpdateMessage) GetMessages() []*LinkUpdateMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type LinkUpdateMessage struct {
	LinkSrc         string     `protobuf:"bytes,1,opt,name=linkSrc,proto3" json:"linkSrc,omitempty"`
	LinkDst         string     `protobuf:"bytes,2,opt,name=linkDst,proto3" json:"linkDst,omitempty"`
	LinkStatus      LinkStatus `protobuf:"varint,3,opt,name=linkStatus,proto3,enum=remoting.LinkStatus" json:"linkStatus,omitempty"`
	ConfigurationId int64      `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	RingNumber      []int32    `protobuf:"varint,5,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	NodeId          *NodeId    `protobuf:"bytes,6,opt,name=nodeId" json:"nodeId,omitempty"`
	Metadata        *Metadata  `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *LinkUpdateMessage) Reset()                    { *m = LinkUpdateMessage{} }
func (m *LinkUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*LinkUpdateMessage) ProtoMessage()               {}
func (*LinkUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{5} }

func (m *LinkUpdateMessage) GetLinkSrc() string {
	if m != nil {
		return m.LinkSrc
	}
	return ""
}

func (m *LinkUpdateMessage) GetLinkDst() string {
	if m != nil {
		return m.LinkDst
	}
	return ""
}

func (m *LinkUpdateMessage) GetLinkStatus() LinkStatus {
	if m != nil {
		return m.LinkStatus
	}
	return LinkStatus_UP
}

func (m *LinkUpdateMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *LinkUpdateMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *LinkUpdateMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *LinkUpdateMessage) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Response struct {
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{6} }

type ConsensusProposal struct {
	Sender          string   `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	ConfigurationId int64    `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Hosts           []string `protobuf:"bytes,3,rep,name=hosts" json:"hosts,omitempty"`
}

func (m *ConsensusProposal) Reset()                    { *m = ConsensusProposal{} }
func (m *ConsensusProposal) String() string            { return proto.CompactTextString(m) }
func (*ConsensusProposal) ProtoMessage()               {}
func (*ConsensusProposal) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{7} }

func (m *ConsensusProposal) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *ConsensusProposal) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *ConsensusProposal) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type ConsensusProposalResponse struct {
}

func (m *ConsensusProposalResponse) Reset()                    { *m = ConsensusProposalResponse{} }
func (m *ConsensusProposalResponse) String() string            { return proto.CompactTextString(m) }
func (*ConsensusProposalResponse) ProtoMessage()               {}
func (*ConsensusProposalResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{8} }

// ******* Node Metadata *********
type Metadata struct {
	Metadata map[string][]byte `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{9} }

func (m *Metadata) GetMetadata() map[string][]byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ProbeMessage struct {
	Sender  string   `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Payload [][]byte `protobuf:"bytes,3,rep,name=payload" json:"payload,omitempty"`
}

func (m *ProbeMessage) Reset()                    { *m = ProbeMessage{} }
func (m *ProbeMessage) String() string            { return proto.CompactTextString(m) }
func (*ProbeMessage) ProtoMessage()               {}
func (*ProbeMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{10} }

func (m *ProbeMessage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *ProbeMessage) GetPayload() [][]byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ProbeResponse struct {
	Status NodeStatus `protobuf:"varint,1,opt,name=status,proto3,enum=remoting.NodeStatus" json:"status,omitempty"`
}

func (m *ProbeResponse) Reset()                    { *m = ProbeResponse{} }
func (m *ProbeResponse) String() string            { return proto.CompactTextString(m) }
func (*ProbeResponse) ProtoMessage()               {}
func (*ProbeResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{11} }

func (m *ProbeResponse) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus_OK
}

func init() {
	proto.RegisterType((*NodeId)(nil), "remoting.NodeId")
	proto.RegisterType((*PreJoinMessage)(nil), "remoting.PreJoinMessage")
	proto.RegisterType((*JoinMessage)(nil), "remoting.JoinMessage")
	proto.RegisterType((*JoinResponse)(nil), "remoting.JoinResponse")
	proto.RegisterType((*BatchedLinkUpdateMessage)(nil), "remoting.BatchedLinkUpdateMessage")
	proto.RegisterType((*LinkUpdateMessage)(nil), "remoting.LinkUpdateMessage")
	proto.RegisterType((*Response)(nil), "remoting.Response")
	proto.RegisterType((*ConsensusProposal)(nil), "remoting.ConsensusProposal")
	proto.RegisterType((*ConsensusProposalResponse)(nil), "remoting.ConsensusProposalResponse")
	proto.RegisterType((*Metadata)(nil), "remoting.Metadata")
	proto.RegisterType((*ProbeMessage)(nil), "remoting.ProbeMessage")
	proto.RegisterType((*ProbeResponse)(nil), "remoting.ProbeResponse")
	proto.RegisterEnum("remoting.JoinStatusCode", JoinStatusCode_name, JoinStatusCode_value)
	proto.RegisterEnum("remoting.LinkStatus", LinkStatus_name, LinkStatus_value)
	proto.RegisterEnum("remoting.NodeStatus", NodeStatus_name, NodeStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MembershipService service

type MembershipServiceClient interface {
	ReceivePreJoinMessage(ctx context.Context, in *PreJoinMessage, opts ...grpc.CallOption) (*JoinResponse, error)
	ReceiveJoinPhase2Message(ctx context.Context, in *JoinMessage, opts ...grpc.CallOption) (*JoinResponse, error)
	ReceiveLinkUpdateMessage(ctx context.Context, in *BatchedLinkUpdateMessage, opts ...grpc.CallOption) (*Response, error)
	ReceiveConsensusProposal(ctx context.Context, in *ConsensusProposal, opts ...grpc.CallOption) (*ConsensusProposalResponse, error)
	ReceiveProbe(ctx context.Context, in *ProbeMessage, opts ...grpc.CallOption) (*ProbeResponse, error)
}

type membershipServiceClient struct {
	cc *grpc.ClientConn
}

func NewMembershipServiceClient(cc *grpc.ClientConn) MembershipServiceClient {
	return &membershipServiceClient{cc}
}

func (c *membershipServiceClient) ReceivePreJoinMessage(ctx context.Context, in *PreJoinMessage, opts ...grpc.CallOption) (*JoinResponse, error) {
	out := new(JoinResponse)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/receivePreJoinMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *membershipServiceClient) ReceiveJoinPhase2Message(ctx context.Context, in *JoinMessage, opts ...grpc.CallOption) (*JoinResponse, error) {
	out := new(JoinResponse)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/receiveJoinPhase2Message", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *membershipServiceClient) ReceiveLinkUpdateMessage(ctx context.Context, in *BatchedLinkUpdateMessage, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/receiveLinkUpdateMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *membershipServiceClient) ReceiveConsensusProposal(ctx context.Context, in *ConsensusProposal, opts ...grpc.CallOption) (*ConsensusProposalResponse, error) {
	out := new(ConsensusProposalResponse)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/receiveConsensusProposal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *membershipServiceClient) ReceiveProbe(ctx context.Context, in *ProbeMessage, opts ...grpc.CallOption) (*ProbeResponse, error) {
	out := new(ProbeResponse)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/receiveProbe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MembershipService service

type MembershipServiceServer interface {
	ReceivePreJoinMessage(context.Context, *PreJoinMessage) (*JoinResponse, error)
	ReceiveJoinPhase2Message(context.Context, *JoinMessage) (*JoinResponse, error)
	ReceiveLinkUpdateMessage(context.Context, *BatchedLinkUpdateMessage) (*Response, error)
	ReceiveConsensusProposal(context.Context, *ConsensusProposal) (*ConsensusProposalResponse, error)
	ReceiveProbe(context.Context, *ProbeMessage) (*ProbeResponse, error)
}

func RegisterMembershipServiceServer(s *grpc.Server, srv MembershipServiceServer) {
	s.RegisterService(&_MembershipService_serviceDesc, srv)
}

func _MembershipService_ReceivePreJoinMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreJoinMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).ReceivePreJoinMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/ReceivePreJoinMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).ReceivePreJoinMessage(ctx, req.(*PreJoinMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MembershipService_ReceiveJoinPhase2Message_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).ReceiveJoinPhase2Message(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/ReceiveJoinPhase2Message",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).ReceiveJoinPhase2Message(ctx, req.(*JoinMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MembershipService_ReceiveLinkUpdateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchedLinkUpdateMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).ReceiveLinkUpdateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/ReceiveLinkUpdateMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).ReceiveLinkUpdateMessage(ctx, req.(*BatchedLinkUpdateMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MembershipService_ReceiveConsensusProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsensusProposal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).ReceiveConsensusProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/ReceiveConsensusProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).ReceiveConsensusProposal(ctx, req.(*ConsensusProposal))
	}
	return interceptor(ctx, in, info, handler)
}

func _MembershipService_ReceiveProbe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProbeMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).ReceiveProbe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/ReceiveProbe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).ReceiveProbe(ctx, req.(*ProbeMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _MembershipService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "remoting.MembershipService",
	HandlerType: (*MembershipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "receivePreJoinMessage",
			Handler:    _MembershipService_ReceivePreJoinMessage_Handler,
		},
		{
			MethodName: "receiveJoinPhase2Message",
			Handler:    _MembershipService_ReceiveJoinPhase2Message_Handler,
		},
		{
			MethodName: "receiveLinkUpdateMessage",
			Handler:    _MembershipService_ReceiveLinkUpdateMessage_Handler,
		},
		{
			MethodName: "receiveConsensusProposal",
			Handler:    _MembershipService_ReceiveConsensusProposal_Handler,
		},
		{
			MethodName: "receiveProbe",
			Handler:    _MembershipService_ReceiveProbe_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rapid.proto",
}

func (m *NodeId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.High != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.High))
	}
	if m.Low != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Low))
	}
	return i, nil
}

func (m *PreJoinMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreJoinMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if m.NodeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n1, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.RingNumber) > 0 {
		dAtA3 := make([]byte, len(m.RingNumber)*10)
		var j2 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	return i, nil
}

func (m *JoinMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if m.NodeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n4, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.RingNumber) > 0 {
		dAtA6 := make([]byte, len(m.RingNumber)*10)
		var j5 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Metadata.Size()))
		n7, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *JoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.StatusCode))
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Identifiers) > 0 {
		for _, msg := range m.Identifiers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterMetadata) > 0 {
		for k, _ := range m.ClusterMetadata {
			dAtA[i] = 0x32
			i++
			v := m.ClusterMetadata[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRapid(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovRapid(uint64(len(k))) + msgSize
			i = encodeVarintRapid(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRapid(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	return i, nil
}

func (m *BatchedLinkUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchedLinkUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinkUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LinkSrc) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.LinkSrc)))
		i += copy(dAtA[i:], m.LinkSrc)
	}
	if len(m.LinkDst) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.LinkDst)))
		i += copy(dAtA[i:], m.LinkDst)
	}
	if m.LinkStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.LinkStatus))
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.RingNumber) > 0 {
		dAtA10 := make([]byte, len(m.RingNumber)*10)
		var j9 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.NodeId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n11, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Metadata != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Metadata.Size()))
		n12, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ConsensusProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusProposal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ConsensusProposalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusProposalResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0xa
			i++
			v := m.Metadata[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovRapid(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovRapid(uint64(len(k))) + byteSize
			i = encodeVarintRapid(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRapid(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *ProbeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sender) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Sender)))
		i += copy(dAtA[i:], m.Sender)
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *ProbeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func encodeVarintRapid(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeId) Size() (n int) {
	var l int
	_ = l
	if m.High != 0 {
		n += 1 + sovRapid(uint64(m.High))
	}
	if m.Low != 0 {
		n += 1 + sovRapid(uint64(m.Low))
	}
	return n
}

func (m *PreJoinMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	return n
}

func (m *JoinMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}

func (m *JoinResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovRapid(uint64(m.StatusCode))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	if len(m.Identifiers) > 0 {
		for _, e := range m.Identifiers {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	if len(m.ClusterMetadata) > 0 {
		for k, v := range m.ClusterMetadata {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRapid(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRapid(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRapid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BatchedLinkUpdateMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *LinkUpdateMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.LinkSrc)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	l = len(m.LinkDst)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.LinkStatus != 0 {
		n += 1 + sovRapid(uint64(m.LinkStatus))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ConsensusProposal) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *ConsensusProposalResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovRapid(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovRapid(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRapid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProbeMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			l = len(b)
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *ProbeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRapid(uint64(m.Status))
	}
	return n
}

func sovRapid(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRapid(x uint64) (n int) {
	return sovRapid(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodeId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreJoinMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreJoinMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreJoinMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (JoinStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifiers = append(m.Identifiers, &NodeId{})
			if err := m.Identifiers[len(m.Identifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterMetadata == nil {
				m.ClusterMetadata = make(map[string]*Metadata)
			}
			var mapkey string
			var mapvalue *Metadata
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRapid
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRapid
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRapid
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Metadata{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRapid(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRapid
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ClusterMetadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchedLinkUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchedLinkUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchedLinkUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &LinkUpdateMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSrc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkSrc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkDst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkDst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkStatus", wireType)
			}
			m.LinkStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkStatus |= (LinkStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusProposalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusProposalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRapid
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthRapid
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRapid(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRapid
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, make([]byte, postIndex-iNdEx))
			copy(m.Payload[len(m.Payload)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (NodeStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRapid(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRapid
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRapid(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRapid = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRapid   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rapid.proto", fileDescriptorRapid) }

var fileDescriptorRapid = []byte{
	// 893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x8e, 0xe2, 0x46,
	0x10, 0x1e, 0x63, 0x60, 0xd8, 0x82, 0x61, 0x3d, 0x1d, 0x76, 0xd6, 0x61, 0x23, 0x84, 0x9c, 0x43,
	0xd0, 0x24, 0xf2, 0x81, 0x44, 0xca, 0x2a, 0x3f, 0x52, 0xf8, 0xf1, 0xce, 0x30, 0xb3, 0x18, 0xab,
	0x81, 0x44, 0xb9, 0x04, 0x19, 0xdc, 0x0b, 0x16, 0x8c, 0x8d, 0xba, 0xcd, 0x44, 0x73, 0x8e, 0xa2,
	0xbc, 0x44, 0x2e, 0xb9, 0xe4, 0x59, 0x92, 0x5b, 0x1e, 0x21, 0x9a, 0x27, 0x89, 0xdc, 0xd8, 0xc6,
	0xc6, 0xec, 0x92, 0xdc, 0x72, 0x73, 0xf7, 0x57, 0xf5, 0x55, 0x55, 0xd7, 0x57, 0x05, 0x50, 0xa4,
	0xe6, 0xda, 0xb6, 0xd4, 0x35, 0x75, 0x3d, 0x17, 0x15, 0x28, 0xb9, 0x73, 0x3d, 0xdb, 0x99, 0x2b,
	0x2a, 0xe4, 0x75, 0xd7, 0x22, 0x3d, 0x0b, 0x21, 0xc8, 0x2e, 0xec, 0xf9, 0x42, 0x16, 0xea, 0x42,
	0x43, 0xc4, 0xfc, 0x1b, 0x49, 0x20, 0xae, 0xdc, 0x1f, 0xe5, 0x0c, 0xbf, 0xf2, 0x3f, 0x95, 0x5f,
	0x05, 0x28, 0x1b, 0x94, 0xdc, 0xb8, 0xb6, 0xd3, 0x27, 0x8c, 0x99, 0x73, 0x82, 0x2e, 0x20, 0xcf,
	0x88, 0x63, 0x11, 0xca, 0x5d, 0x9f, 0xe0, 0xe0, 0x84, 0x1a, 0x90, 0x77, 0x38, 0x35, 0xf7, 0x2f,
	0x36, 0x25, 0x35, 0x8c, 0xaa, 0x6e, 0x43, 0xe2, 0x00, 0x47, 0x35, 0x00, 0x6a, 0x3b, 0x73, 0x7d,
	0x73, 0x37, 0x25, 0x54, 0x16, 0xeb, 0x62, 0x23, 0x87, 0x63, 0x37, 0xa8, 0x01, 0x4f, 0x67, 0xae,
	0xf3, 0xc6, 0x9e, 0x6f, 0xa8, 0xe9, 0xd9, 0xae, 0xd3, 0xb3, 0xe4, 0x2c, 0x4f, 0x69, 0xff, 0x5a,
	0xf9, 0x53, 0x80, 0xe2, 0xff, 0x34, 0x37, 0xa4, 0x42, 0xe1, 0x8e, 0x78, 0xa6, 0x65, 0x7a, 0xa6,
	0x9c, 0xe3, 0x51, 0xd1, 0x2e, 0x6a, 0x3f, 0x40, 0x70, 0x64, 0xa3, 0xfc, 0x24, 0x42, 0xc9, 0xaf,
	0x05, 0x13, 0xb6, 0x76, 0x1d, 0xf6, 0xf6, 0x62, 0x5e, 0x02, 0x30, 0xcf, 0xf4, 0x36, 0xac, 0xe3,
	0x5a, 0x84, 0x17, 0x54, 0x6e, 0xca, 0x3b, 0x6a, 0x9f, 0x63, 0x18, 0xe1, 0x38, 0x66, 0x7b, 0x28,
	0x79, 0xf1, 0x70, 0xf2, 0x15, 0xc8, 0x2d, 0x5c, 0xe6, 0x31, 0x39, 0x5b, 0x17, 0x1b, 0x4f, 0xf0,
	0xf6, 0x80, 0x9a, 0x50, 0xb4, 0x2d, 0xe2, 0x78, 0xf6, 0x1b, 0x9b, 0x50, 0x26, 0xe7, 0xea, 0xe2,
	0xc1, 0xb7, 0x8c, 0x1b, 0xa1, 0x31, 0x3c, 0x9d, 0xad, 0x36, 0xcc, 0x23, 0x34, 0xac, 0x59, 0xce,
	0x73, 0xbf, 0x8f, 0x93, 0x29, 0x87, 0x65, 0xab, 0x9d, 0xa4, 0xb5, 0xe6, 0x78, 0xf4, 0x01, 0xef,
	0x73, 0x54, 0xbf, 0x85, 0xca, 0x21, 0x43, 0x5f, 0xc2, 0x4b, 0xf2, 0x10, 0xbc, 0x98, 0xff, 0x89,
	0x1a, 0x90, 0xbb, 0x37, 0x57, 0x1b, 0x12, 0xb4, 0xfe, 0x50, 0x13, 0xb6, 0x06, 0x5f, 0x64, 0x5e,
	0x0a, 0xca, 0x12, 0xe4, 0xb6, 0xe9, 0xcd, 0x16, 0xc4, 0x7a, 0x6d, 0x3b, 0xcb, 0xf1, 0xda, 0x32,
	0x3d, 0x72, 0x4c, 0x5d, 0x9f, 0xfb, 0x9d, 0xe6, 0x26, 0x8c, 0x2b, 0xa6, 0xd8, 0x7c, 0xb1, 0x0b,
	0x92, 0xa2, 0xc1, 0x91, 0xb1, 0xf2, 0x5b, 0x06, 0xce, 0xd3, 0x61, 0x64, 0x38, 0x5d, 0xd9, 0xce,
	0x72, 0x48, 0x67, 0x41, 0x9c, 0xf0, 0x18, 0x22, 0x5d, 0xe6, 0xf1, 0x62, 0x02, 0xa4, 0xcb, 0x3c,
	0xf4, 0x19, 0x00, 0x37, 0xe2, 0xbd, 0xe6, 0x4d, 0x2d, 0x37, 0x2b, 0xc9, 0x24, 0xb6, 0x18, 0x8e,
	0xd9, 0xfd, 0x07, 0x31, 0x27, 0xc7, 0x22, 0x77, 0x60, 0x2c, 0xc2, 0x01, 0xcb, 0x1f, 0x19, 0xb0,
	0xf8, 0x58, 0x9c, 0xfe, 0x8b, 0xb1, 0x00, 0x28, 0x84, 0xd2, 0x50, 0x96, 0x70, 0xde, 0xf1, 0x3f,
	0x1c, 0xb6, 0x61, 0x06, 0x75, 0xd7, 0x2e, 0x33, 0x57, 0xef, 0x98, 0xf9, 0x54, 0x71, 0x99, 0x23,
	0x62, 0x17, 0x63, 0x62, 0x57, 0x5e, 0xc0, 0xfb, 0xa9, 0x60, 0x51, 0x26, 0x3f, 0x0b, 0x50, 0x08,
	0x93, 0x45, 0x5f, 0xc5, 0x4a, 0x12, 0x78, 0xff, 0xeb, 0xe9, 0x92, 0xd4, 0xa4, 0xa0, 0x23, 0x8f,
	0xea, 0x97, 0x70, 0x76, 0x4c, 0xc2, 0x95, 0xb8, 0x84, 0x4b, 0x71, 0xb9, 0x7e, 0x03, 0x25, 0x83,
	0xba, 0xd3, 0xa3, 0x12, 0x95, 0xe1, 0x74, 0x6d, 0x3e, 0xac, 0x5c, 0xd3, 0xe2, 0x45, 0x96, 0x70,
	0x78, 0x54, 0xbe, 0x86, 0x33, 0xce, 0x10, 0xad, 0x9d, 0x4f, 0x20, 0xbf, 0x5d, 0x19, 0x9c, 0x22,
	0x21, 0x23, 0xbf, 0x95, 0x81, 0x8c, 0x02, 0x9b, 0xcb, 0x5f, 0x04, 0x28, 0x27, 0x37, 0x0e, 0xfa,
	0x00, 0xe4, 0xeb, 0xc1, 0x70, 0xa4, 0xb7, 0xfa, 0xda, 0xa4, 0xf5, 0x1a, 0x6b, 0xad, 0xee, 0xf7,
	0x93, 0x9e, 0x3e, 0xc1, 0x3d, 0xfd, 0x4a, 0x3a, 0x41, 0x32, 0x54, 0xc6, 0xe3, 0x5e, 0x37, 0x85,
	0x08, 0x48, 0x82, 0xd2, 0xb0, 0xf5, 0x4a, 0x9b, 0x8c, 0x06, 0x93, 0x9b, 0x41, 0x4f, 0x97, 0x32,
	0x08, 0x41, 0xb9, 0x33, 0xd0, 0x5f, 0xf5, 0xae, 0x26, 0x9d, 0xeb, 0x96, 0x7e, 0xa5, 0x75, 0x25,
	0x11, 0x3d, 0x87, 0xf7, 0xfa, 0x5a, 0xbf, 0xad, 0xe1, 0xe1, 0x75, 0xcf, 0x98, 0x60, 0xed, 0x46,
	0xeb, 0x8c, 0xb4, 0xae, 0x94, 0xbd, 0xac, 0x01, 0xec, 0x64, 0x8e, 0xf2, 0x90, 0x19, 0x1b, 0xd2,
	0x09, 0x2a, 0x40, 0xb6, 0x3b, 0xf8, 0x4e, 0x97, 0x84, 0xcb, 0x8f, 0x00, 0x76, 0xf9, 0xfb, 0xf8,
	0xe0, 0x56, 0x3a, 0x41, 0xe7, 0x70, 0xd6, 0x1e, 0x0c, 0x46, 0xc3, 0x11, 0x6e, 0x19, 0x06, 0xcf,
	0xa3, 0xf9, 0xbb, 0x08, 0xe7, 0x7d, 0xe2, 0xcb, 0x9a, 0x2d, 0xec, 0xf5, 0x90, 0xd0, 0x7b, 0x7b,
	0x46, 0xd0, 0x2d, 0x3c, 0xa3, 0x64, 0x46, 0xec, 0x7b, 0xb2, 0xf7, 0x7b, 0x18, 0x5b, 0xbd, 0x49,
	0xa4, 0x7a, 0x71, 0x78, 0xc3, 0x29, 0x27, 0xe8, 0x16, 0xe4, 0x80, 0xcc, 0x07, 0x8c, 0x85, 0xc9,
	0x48, 0x33, 0xe4, 0x7b, 0x96, 0xf4, 0x3a, 0x4e, 0x36, 0x8a, 0xc8, 0xd2, 0xbb, 0x44, 0xd9, 0x79,
	0xbd, 0x6d, 0xad, 0x55, 0x63, 0xf3, 0x17, 0x63, 0xfd, 0x21, 0x62, 0x4d, 0x8f, 0x5c, 0x6c, 0xbd,
	0xa5, 0xc0, 0xea, 0x87, 0xef, 0x00, 0x63, 0xfc, 0x2d, 0x28, 0x45, 0xef, 0xe9, 0x4e, 0x09, 0xba,
	0x88, 0x3f, 0xe3, 0x4e, 0xd1, 0xd5, 0xe7, 0x7b, 0xf7, 0x3b, 0x8a, 0xf6, 0xe5, 0x1f, 0x8f, 0x35,
	0xe1, 0xaf, 0xc7, 0x9a, 0xf0, 0xf7, 0x63, 0x4d, 0x00, 0x69, 0xe6, 0xde, 0xa9, 0xf7, 0x74, 0xae,
	0x06, 0xff, 0x7c, 0xa6, 0xed, 0x02, 0x0e, 0x3c, 0x0d, 0x61, 0x9a, 0xe7, 0xff, 0x84, 0x3e, 0xfd,
	0x27, 0x00, 0x00, 0xff, 0xff, 0xff, 0xbf, 0xc4, 0xf3, 0x18, 0x09, 0x00, 0x00,
}
