// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rapid.proto

/*
	Package remoting is a generated protocol buffer package.

	It is generated from these files:
		rapid.proto

	It has these top-level messages:
		Endpoint
		RapidRequest
		RapidResponse
		NodeId
		PreJoinMessage
		JoinMessage
		JoinResponse
		BatchedLinkUpdateMessage
		LinkUpdateMessage
		Response
		FastRoundPhase2BMessage
		Rank
		Phase1AMessage
		Phase1BMessage
		Phase2AMessage
		Phase2BMessage
		ConsensusResponse
		Metadata
		ProbeMessage
		ProbeResponse
*/
package remoting

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type JoinStatusCode int32

const (
	JoinStatusCode_HOSTNAME_ALREADY_IN_RING JoinStatusCode = 0
	JoinStatusCode_UUID_ALREADY_IN_RING     JoinStatusCode = 1
	JoinStatusCode_SAFE_TO_JOIN             JoinStatusCode = 2
	JoinStatusCode_CONFIG_CHANGED           JoinStatusCode = 3
	JoinStatusCode_MEMBERSHIP_REJECTED      JoinStatusCode = 4
)

var JoinStatusCode_name = map[int32]string{
	0: "HOSTNAME_ALREADY_IN_RING",
	1: "UUID_ALREADY_IN_RING",
	2: "SAFE_TO_JOIN",
	3: "CONFIG_CHANGED",
	4: "MEMBERSHIP_REJECTED",
}
var JoinStatusCode_value = map[string]int32{
	"HOSTNAME_ALREADY_IN_RING": 0,
	"UUID_ALREADY_IN_RING":     1,
	"SAFE_TO_JOIN":             2,
	"CONFIG_CHANGED":           3,
	"MEMBERSHIP_REJECTED":      4,
}

func (x JoinStatusCode) String() string {
	return proto.EnumName(JoinStatusCode_name, int32(x))
}
func (JoinStatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{0} }

type LinkStatus int32

const (
	LinkStatus_UP   LinkStatus = 0
	LinkStatus_DOWN LinkStatus = 1
)

var LinkStatus_name = map[int32]string{
	0: "UP",
	1: "DOWN",
}
var LinkStatus_value = map[string]int32{
	"UP":   0,
	"DOWN": 1,
}

func (x LinkStatus) String() string {
	return proto.EnumName(LinkStatus_name, int32(x))
}
func (LinkStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{1} }

type NodeStatus int32

const (
	NodeStatus_OK            NodeStatus = 0
	NodeStatus_BOOTSTRAPPING NodeStatus = 1
)

var NodeStatus_name = map[int32]string{
	0: "OK",
	1: "BOOTSTRAPPING",
}
var NodeStatus_value = map[string]int32{
	"OK":            0,
	"BOOTSTRAPPING": 1,
}

func (x NodeStatus) String() string {
	return proto.EnumName(NodeStatus_name, int32(x))
}
func (NodeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorRapid, []int{2} }

type Endpoint struct {
	Hostname string `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{0} }

func (m *Endpoint) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Endpoint) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// All-in-one message type.
type RapidRequest struct {
	// Types that are valid to be assigned to Content:
	//	*RapidRequest_PreJoinMessage
	//	*RapidRequest_JoinMessage
	//	*RapidRequest_BatchedLinkUpdateMessage
	//	*RapidRequest_ProbeMessage
	//	*RapidRequest_FastRoundPhase2BMessage
	//	*RapidRequest_Phase1AMessage
	//	*RapidRequest_Phase1BMessage
	//	*RapidRequest_Phase2AMessage
	//	*RapidRequest_Phase2BMessage
	Content isRapidRequest_Content `protobuf_oneof:"content"`
}

func (m *RapidRequest) Reset()                    { *m = RapidRequest{} }
func (m *RapidRequest) String() string            { return proto.CompactTextString(m) }
func (*RapidRequest) ProtoMessage()               {}
func (*RapidRequest) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{1} }

type isRapidRequest_Content interface {
	isRapidRequest_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RapidRequest_PreJoinMessage struct {
	PreJoinMessage *PreJoinMessage `protobuf:"bytes,1,opt,name=preJoinMessage,oneof"`
}
type RapidRequest_JoinMessage struct {
	JoinMessage *JoinMessage `protobuf:"bytes,2,opt,name=joinMessage,oneof"`
}
type RapidRequest_BatchedLinkUpdateMessage struct {
	BatchedLinkUpdateMessage *BatchedLinkUpdateMessage `protobuf:"bytes,3,opt,name=batchedLinkUpdateMessage,oneof"`
}
type RapidRequest_ProbeMessage struct {
	ProbeMessage *ProbeMessage `protobuf:"bytes,4,opt,name=probeMessage,oneof"`
}
type RapidRequest_FastRoundPhase2BMessage struct {
	FastRoundPhase2BMessage *FastRoundPhase2BMessage `protobuf:"bytes,5,opt,name=fastRoundPhase2bMessage,oneof"`
}
type RapidRequest_Phase1AMessage struct {
	Phase1AMessage *Phase1AMessage `protobuf:"bytes,6,opt,name=phase1aMessage,oneof"`
}
type RapidRequest_Phase1BMessage struct {
	Phase1BMessage *Phase1BMessage `protobuf:"bytes,7,opt,name=phase1bMessage,oneof"`
}
type RapidRequest_Phase2AMessage struct {
	Phase2AMessage *Phase2AMessage `protobuf:"bytes,8,opt,name=phase2aMessage,oneof"`
}
type RapidRequest_Phase2BMessage struct {
	Phase2BMessage *Phase2BMessage `protobuf:"bytes,9,opt,name=phase2bMessage,oneof"`
}

func (*RapidRequest_PreJoinMessage) isRapidRequest_Content()           {}
func (*RapidRequest_JoinMessage) isRapidRequest_Content()              {}
func (*RapidRequest_BatchedLinkUpdateMessage) isRapidRequest_Content() {}
func (*RapidRequest_ProbeMessage) isRapidRequest_Content()             {}
func (*RapidRequest_FastRoundPhase2BMessage) isRapidRequest_Content()  {}
func (*RapidRequest_Phase1AMessage) isRapidRequest_Content()           {}
func (*RapidRequest_Phase1BMessage) isRapidRequest_Content()           {}
func (*RapidRequest_Phase2AMessage) isRapidRequest_Content()           {}
func (*RapidRequest_Phase2BMessage) isRapidRequest_Content()           {}

func (m *RapidRequest) GetContent() isRapidRequest_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RapidRequest) GetPreJoinMessage() *PreJoinMessage {
	if x, ok := m.GetContent().(*RapidRequest_PreJoinMessage); ok {
		return x.PreJoinMessage
	}
	return nil
}

func (m *RapidRequest) GetJoinMessage() *JoinMessage {
	if x, ok := m.GetContent().(*RapidRequest_JoinMessage); ok {
		return x.JoinMessage
	}
	return nil
}

func (m *RapidRequest) GetBatchedLinkUpdateMessage() *BatchedLinkUpdateMessage {
	if x, ok := m.GetContent().(*RapidRequest_BatchedLinkUpdateMessage); ok {
		return x.BatchedLinkUpdateMessage
	}
	return nil
}

func (m *RapidRequest) GetProbeMessage() *ProbeMessage {
	if x, ok := m.GetContent().(*RapidRequest_ProbeMessage); ok {
		return x.ProbeMessage
	}
	return nil
}

func (m *RapidRequest) GetFastRoundPhase2BMessage() *FastRoundPhase2BMessage {
	if x, ok := m.GetContent().(*RapidRequest_FastRoundPhase2BMessage); ok {
		return x.FastRoundPhase2BMessage
	}
	return nil
}

func (m *RapidRequest) GetPhase1AMessage() *Phase1AMessage {
	if x, ok := m.GetContent().(*RapidRequest_Phase1AMessage); ok {
		return x.Phase1AMessage
	}
	return nil
}

func (m *RapidRequest) GetPhase1BMessage() *Phase1BMessage {
	if x, ok := m.GetContent().(*RapidRequest_Phase1BMessage); ok {
		return x.Phase1BMessage
	}
	return nil
}

func (m *RapidRequest) GetPhase2AMessage() *Phase2AMessage {
	if x, ok := m.GetContent().(*RapidRequest_Phase2AMessage); ok {
		return x.Phase2AMessage
	}
	return nil
}

func (m *RapidRequest) GetPhase2BMessage() *Phase2BMessage {
	if x, ok := m.GetContent().(*RapidRequest_Phase2BMessage); ok {
		return x.Phase2BMessage
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RapidRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RapidRequest_OneofMarshaler, _RapidRequest_OneofUnmarshaler, _RapidRequest_OneofSizer, []interface{}{
		(*RapidRequest_PreJoinMessage)(nil),
		(*RapidRequest_JoinMessage)(nil),
		(*RapidRequest_BatchedLinkUpdateMessage)(nil),
		(*RapidRequest_ProbeMessage)(nil),
		(*RapidRequest_FastRoundPhase2BMessage)(nil),
		(*RapidRequest_Phase1AMessage)(nil),
		(*RapidRequest_Phase1BMessage)(nil),
		(*RapidRequest_Phase2AMessage)(nil),
		(*RapidRequest_Phase2BMessage)(nil),
	}
}

func _RapidRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RapidRequest)
	// content
	switch x := m.Content.(type) {
	case *RapidRequest_PreJoinMessage:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreJoinMessage); err != nil {
			return err
		}
	case *RapidRequest_JoinMessage:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JoinMessage); err != nil {
			return err
		}
	case *RapidRequest_BatchedLinkUpdateMessage:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BatchedLinkUpdateMessage); err != nil {
			return err
		}
	case *RapidRequest_ProbeMessage:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProbeMessage); err != nil {
			return err
		}
	case *RapidRequest_FastRoundPhase2BMessage:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FastRoundPhase2BMessage); err != nil {
			return err
		}
	case *RapidRequest_Phase1AMessage:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Phase1AMessage); err != nil {
			return err
		}
	case *RapidRequest_Phase1BMessage:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Phase1BMessage); err != nil {
			return err
		}
	case *RapidRequest_Phase2AMessage:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Phase2AMessage); err != nil {
			return err
		}
	case *RapidRequest_Phase2BMessage:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Phase2BMessage); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RapidRequest.Content has unexpected type %T", x)
	}
	return nil
}

func _RapidRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RapidRequest)
	switch tag {
	case 1: // content.preJoinMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreJoinMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_PreJoinMessage{msg}
		return true, err
	case 2: // content.joinMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JoinMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_JoinMessage{msg}
		return true, err
	case 3: // content.batchedLinkUpdateMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BatchedLinkUpdateMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_BatchedLinkUpdateMessage{msg}
		return true, err
	case 4: // content.probeMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProbeMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_ProbeMessage{msg}
		return true, err
	case 5: // content.fastRoundPhase2bMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FastRoundPhase2BMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_FastRoundPhase2BMessage{msg}
		return true, err
	case 6: // content.phase1aMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Phase1AMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_Phase1AMessage{msg}
		return true, err
	case 7: // content.phase1bMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Phase1BMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_Phase1BMessage{msg}
		return true, err
	case 8: // content.phase2aMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Phase2AMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_Phase2AMessage{msg}
		return true, err
	case 9: // content.phase2bMessage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Phase2BMessage)
		err := b.DecodeMessage(msg)
		m.Content = &RapidRequest_Phase2BMessage{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RapidRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RapidRequest)
	// content
	switch x := m.Content.(type) {
	case *RapidRequest_PreJoinMessage:
		s := proto.Size(x.PreJoinMessage)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_JoinMessage:
		s := proto.Size(x.JoinMessage)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_BatchedLinkUpdateMessage:
		s := proto.Size(x.BatchedLinkUpdateMessage)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_ProbeMessage:
		s := proto.Size(x.ProbeMessage)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_FastRoundPhase2BMessage:
		s := proto.Size(x.FastRoundPhase2BMessage)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_Phase1AMessage:
		s := proto.Size(x.Phase1AMessage)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_Phase1BMessage:
		s := proto.Size(x.Phase1BMessage)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_Phase2AMessage:
		s := proto.Size(x.Phase2AMessage)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidRequest_Phase2BMessage:
		s := proto.Size(x.Phase2BMessage)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RapidResponse struct {
	// Types that are valid to be assigned to Content:
	//	*RapidResponse_JoinResponse
	//	*RapidResponse_Response
	//	*RapidResponse_ConsensusResponse
	//	*RapidResponse_ProbeResponse
	Content isRapidResponse_Content `protobuf_oneof:"content"`
}

func (m *RapidResponse) Reset()                    { *m = RapidResponse{} }
func (m *RapidResponse) String() string            { return proto.CompactTextString(m) }
func (*RapidResponse) ProtoMessage()               {}
func (*RapidResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{2} }

type isRapidResponse_Content interface {
	isRapidResponse_Content()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RapidResponse_JoinResponse struct {
	JoinResponse *JoinResponse `protobuf:"bytes,1,opt,name=joinResponse,oneof"`
}
type RapidResponse_Response struct {
	Response *Response `protobuf:"bytes,2,opt,name=response,oneof"`
}
type RapidResponse_ConsensusResponse struct {
	ConsensusResponse *ConsensusResponse `protobuf:"bytes,3,opt,name=consensusResponse,oneof"`
}
type RapidResponse_ProbeResponse struct {
	ProbeResponse *ProbeResponse `protobuf:"bytes,4,opt,name=probeResponse,oneof"`
}

func (*RapidResponse_JoinResponse) isRapidResponse_Content()      {}
func (*RapidResponse_Response) isRapidResponse_Content()          {}
func (*RapidResponse_ConsensusResponse) isRapidResponse_Content() {}
func (*RapidResponse_ProbeResponse) isRapidResponse_Content()     {}

func (m *RapidResponse) GetContent() isRapidResponse_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *RapidResponse) GetJoinResponse() *JoinResponse {
	if x, ok := m.GetContent().(*RapidResponse_JoinResponse); ok {
		return x.JoinResponse
	}
	return nil
}

func (m *RapidResponse) GetResponse() *Response {
	if x, ok := m.GetContent().(*RapidResponse_Response); ok {
		return x.Response
	}
	return nil
}

func (m *RapidResponse) GetConsensusResponse() *ConsensusResponse {
	if x, ok := m.GetContent().(*RapidResponse_ConsensusResponse); ok {
		return x.ConsensusResponse
	}
	return nil
}

func (m *RapidResponse) GetProbeResponse() *ProbeResponse {
	if x, ok := m.GetContent().(*RapidResponse_ProbeResponse); ok {
		return x.ProbeResponse
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RapidResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RapidResponse_OneofMarshaler, _RapidResponse_OneofUnmarshaler, _RapidResponse_OneofSizer, []interface{}{
		(*RapidResponse_JoinResponse)(nil),
		(*RapidResponse_Response)(nil),
		(*RapidResponse_ConsensusResponse)(nil),
		(*RapidResponse_ProbeResponse)(nil),
	}
}

func _RapidResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RapidResponse)
	// content
	switch x := m.Content.(type) {
	case *RapidResponse_JoinResponse:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JoinResponse); err != nil {
			return err
		}
	case *RapidResponse_Response:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Response); err != nil {
			return err
		}
	case *RapidResponse_ConsensusResponse:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConsensusResponse); err != nil {
			return err
		}
	case *RapidResponse_ProbeResponse:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProbeResponse); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RapidResponse.Content has unexpected type %T", x)
	}
	return nil
}

func _RapidResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RapidResponse)
	switch tag {
	case 1: // content.joinResponse
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JoinResponse)
		err := b.DecodeMessage(msg)
		m.Content = &RapidResponse_JoinResponse{msg}
		return true, err
	case 2: // content.response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Response)
		err := b.DecodeMessage(msg)
		m.Content = &RapidResponse_Response{msg}
		return true, err
	case 3: // content.consensusResponse
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConsensusResponse)
		err := b.DecodeMessage(msg)
		m.Content = &RapidResponse_ConsensusResponse{msg}
		return true, err
	case 4: // content.probeResponse
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProbeResponse)
		err := b.DecodeMessage(msg)
		m.Content = &RapidResponse_ProbeResponse{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RapidResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RapidResponse)
	// content
	switch x := m.Content.(type) {
	case *RapidResponse_JoinResponse:
		s := proto.Size(x.JoinResponse)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidResponse_Response:
		s := proto.Size(x.Response)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidResponse_ConsensusResponse:
		s := proto.Size(x.ConsensusResponse)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RapidResponse_ProbeResponse:
		s := proto.Size(x.ProbeResponse)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NodeId struct {
	High int64 `protobuf:"varint,1,opt,name=high,proto3" json:"high,omitempty"`
	Low  int64 `protobuf:"varint,2,opt,name=low,proto3" json:"low,omitempty"`
}

func (m *NodeId) Reset()                    { *m = NodeId{} }
func (m *NodeId) String() string            { return proto.CompactTextString(m) }
func (*NodeId) ProtoMessage()               {}
func (*NodeId) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{3} }

func (m *NodeId) GetHigh() int64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *NodeId) GetLow() int64 {
	if m != nil {
		return m.Low
	}
	return 0
}

// TODO: JoinMessage and JoinResponse are overloaded because they are being used for phase 1 and 2 of the bootstrap.
type PreJoinMessage struct {
	Sender          *Endpoint `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	NodeId          *NodeId   `protobuf:"bytes,2,opt,name=nodeId" json:"nodeId,omitempty"`
	RingNumber      []int32   `protobuf:"varint,3,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	ConfigurationId int64     `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
}

func (m *PreJoinMessage) Reset()                    { *m = PreJoinMessage{} }
func (m *PreJoinMessage) String() string            { return proto.CompactTextString(m) }
func (*PreJoinMessage) ProtoMessage()               {}
func (*PreJoinMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{4} }

func (m *PreJoinMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *PreJoinMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *PreJoinMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *PreJoinMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

type JoinMessage struct {
	Sender          *Endpoint `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	NodeId          *NodeId   `protobuf:"bytes,2,opt,name=nodeId" json:"nodeId,omitempty"`
	RingNumber      []int32   `protobuf:"varint,3,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	ConfigurationId int64     `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Metadata        *Metadata `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *JoinMessage) Reset()                    { *m = JoinMessage{} }
func (m *JoinMessage) String() string            { return proto.CompactTextString(m) }
func (*JoinMessage) ProtoMessage()               {}
func (*JoinMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{5} }

func (m *JoinMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *JoinMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *JoinMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *JoinMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *JoinMessage) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type JoinResponse struct {
	Sender          *Endpoint            `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	StatusCode      JoinStatusCode       `protobuf:"varint,2,opt,name=statusCode,proto3,enum=remoting.JoinStatusCode" json:"statusCode,omitempty"`
	ConfigurationId int64                `protobuf:"varint,3,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Endpoints       []*Endpoint          `protobuf:"bytes,4,rep,name=endpoints" json:"endpoints,omitempty"`
	Identifiers     []*NodeId            `protobuf:"bytes,5,rep,name=identifiers" json:"identifiers,omitempty"`
	ClusterMetadata map[string]*Metadata `protobuf:"bytes,6,rep,name=clusterMetadata" json:"clusterMetadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *JoinResponse) Reset()                    { *m = JoinResponse{} }
func (m *JoinResponse) String() string            { return proto.CompactTextString(m) }
func (*JoinResponse) ProtoMessage()               {}
func (*JoinResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{6} }

func (m *JoinResponse) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *JoinResponse) GetStatusCode() JoinStatusCode {
	if m != nil {
		return m.StatusCode
	}
	return JoinStatusCode_HOSTNAME_ALREADY_IN_RING
}

func (m *JoinResponse) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *JoinResponse) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *JoinResponse) GetIdentifiers() []*NodeId {
	if m != nil {
		return m.Identifiers
	}
	return nil
}

func (m *JoinResponse) GetClusterMetadata() map[string]*Metadata {
	if m != nil {
		return m.ClusterMetadata
	}
	return nil
}

type BatchedLinkUpdateMessage struct {
	Sender   *Endpoint            `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	Messages []*LinkUpdateMessage `protobuf:"bytes,3,rep,name=messages" json:"messages,omitempty"`
}

func (m *BatchedLinkUpdateMessage) Reset()                    { *m = BatchedLinkUpdateMessage{} }
func (m *BatchedLinkUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*BatchedLinkUpdateMessage) ProtoMessage()               {}
func (*BatchedLinkUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{7} }

func (m *BatchedLinkUpdateMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *BatchedLinkUpdateMessage) GetMessages() []*LinkUpdateMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type LinkUpdateMessage struct {
	LinkSrc         *Endpoint  `protobuf:"bytes,1,opt,name=linkSrc" json:"linkSrc,omitempty"`
	LinkDst         *Endpoint  `protobuf:"bytes,2,opt,name=linkDst" json:"linkDst,omitempty"`
	LinkStatus      LinkStatus `protobuf:"varint,3,opt,name=linkStatus,proto3,enum=remoting.LinkStatus" json:"linkStatus,omitempty"`
	ConfigurationId int64      `protobuf:"varint,4,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	RingNumber      []int32    `protobuf:"varint,5,rep,packed,name=ringNumber" json:"ringNumber,omitempty"`
	NodeId          *NodeId    `protobuf:"bytes,6,opt,name=nodeId" json:"nodeId,omitempty"`
	Metadata        *Metadata  `protobuf:"bytes,7,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *LinkUpdateMessage) Reset()                    { *m = LinkUpdateMessage{} }
func (m *LinkUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*LinkUpdateMessage) ProtoMessage()               {}
func (*LinkUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{8} }

func (m *LinkUpdateMessage) GetLinkSrc() *Endpoint {
	if m != nil {
		return m.LinkSrc
	}
	return nil
}

func (m *LinkUpdateMessage) GetLinkDst() *Endpoint {
	if m != nil {
		return m.LinkDst
	}
	return nil
}

func (m *LinkUpdateMessage) GetLinkStatus() LinkStatus {
	if m != nil {
		return m.LinkStatus
	}
	return LinkStatus_UP
}

func (m *LinkUpdateMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *LinkUpdateMessage) GetRingNumber() []int32 {
	if m != nil {
		return m.RingNumber
	}
	return nil
}

func (m *LinkUpdateMessage) GetNodeId() *NodeId {
	if m != nil {
		return m.NodeId
	}
	return nil
}

func (m *LinkUpdateMessage) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type Response struct {
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{9} }

type FastRoundPhase2BMessage struct {
	Sender          *Endpoint   `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	ConfigurationId int64       `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Endpoints       []*Endpoint `protobuf:"bytes,3,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *FastRoundPhase2BMessage) Reset()                    { *m = FastRoundPhase2BMessage{} }
func (m *FastRoundPhase2BMessage) String() string            { return proto.CompactTextString(m) }
func (*FastRoundPhase2BMessage) ProtoMessage()               {}
func (*FastRoundPhase2BMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{10} }

func (m *FastRoundPhase2BMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *FastRoundPhase2BMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *FastRoundPhase2BMessage) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

// ******* Classic Paxos messages *********
type Rank struct {
	Round     int32 `protobuf:"varint,1,opt,name=round,proto3" json:"round,omitempty"`
	NodeIndex int32 `protobuf:"varint,2,opt,name=nodeIndex,proto3" json:"nodeIndex,omitempty"`
}

func (m *Rank) Reset()                    { *m = Rank{} }
func (m *Rank) String() string            { return proto.CompactTextString(m) }
func (*Rank) ProtoMessage()               {}
func (*Rank) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{11} }

func (m *Rank) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *Rank) GetNodeIndex() int32 {
	if m != nil {
		return m.NodeIndex
	}
	return 0
}

type Phase1AMessage struct {
	Sender          *Endpoint `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	ConfigurationId int64     `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Rank            *Rank     `protobuf:"bytes,3,opt,name=rank" json:"rank,omitempty"`
}

func (m *Phase1AMessage) Reset()                    { *m = Phase1AMessage{} }
func (m *Phase1AMessage) String() string            { return proto.CompactTextString(m) }
func (*Phase1AMessage) ProtoMessage()               {}
func (*Phase1AMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{12} }

func (m *Phase1AMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Phase1AMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *Phase1AMessage) GetRank() *Rank {
	if m != nil {
		return m.Rank
	}
	return nil
}

type Phase1BMessage struct {
	Sender          *Endpoint   `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	ConfigurationId int64       `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Rnd             *Rank       `protobuf:"bytes,3,opt,name=rnd" json:"rnd,omitempty"`
	Vrnd            *Rank       `protobuf:"bytes,4,opt,name=vrnd" json:"vrnd,omitempty"`
	Vval            []*Endpoint `protobuf:"bytes,5,rep,name=vval" json:"vval,omitempty"`
}

func (m *Phase1BMessage) Reset()                    { *m = Phase1BMessage{} }
func (m *Phase1BMessage) String() string            { return proto.CompactTextString(m) }
func (*Phase1BMessage) ProtoMessage()               {}
func (*Phase1BMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{13} }

func (m *Phase1BMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Phase1BMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *Phase1BMessage) GetRnd() *Rank {
	if m != nil {
		return m.Rnd
	}
	return nil
}

func (m *Phase1BMessage) GetVrnd() *Rank {
	if m != nil {
		return m.Vrnd
	}
	return nil
}

func (m *Phase1BMessage) GetVval() []*Endpoint {
	if m != nil {
		return m.Vval
	}
	return nil
}

type Phase2AMessage struct {
	Sender          *Endpoint   `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	ConfigurationId int64       `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Rnd             *Rank       `protobuf:"bytes,3,opt,name=rnd" json:"rnd,omitempty"`
	Vval            []*Endpoint `protobuf:"bytes,5,rep,name=vval" json:"vval,omitempty"`
}

func (m *Phase2AMessage) Reset()                    { *m = Phase2AMessage{} }
func (m *Phase2AMessage) String() string            { return proto.CompactTextString(m) }
func (*Phase2AMessage) ProtoMessage()               {}
func (*Phase2AMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{14} }

func (m *Phase2AMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Phase2AMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *Phase2AMessage) GetRnd() *Rank {
	if m != nil {
		return m.Rnd
	}
	return nil
}

func (m *Phase2AMessage) GetVval() []*Endpoint {
	if m != nil {
		return m.Vval
	}
	return nil
}

type Phase2BMessage struct {
	Sender          *Endpoint   `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	ConfigurationId int64       `protobuf:"varint,2,opt,name=configurationId,proto3" json:"configurationId,omitempty"`
	Rnd             *Rank       `protobuf:"bytes,3,opt,name=rnd" json:"rnd,omitempty"`
	Endpoints       []*Endpoint `protobuf:"bytes,4,rep,name=endpoints" json:"endpoints,omitempty"`
}

func (m *Phase2BMessage) Reset()                    { *m = Phase2BMessage{} }
func (m *Phase2BMessage) String() string            { return proto.CompactTextString(m) }
func (*Phase2BMessage) ProtoMessage()               {}
func (*Phase2BMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{15} }

func (m *Phase2BMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Phase2BMessage) GetConfigurationId() int64 {
	if m != nil {
		return m.ConfigurationId
	}
	return 0
}

func (m *Phase2BMessage) GetRnd() *Rank {
	if m != nil {
		return m.Rnd
	}
	return nil
}

func (m *Phase2BMessage) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

type ConsensusResponse struct {
}

func (m *ConsensusResponse) Reset()                    { *m = ConsensusResponse{} }
func (m *ConsensusResponse) String() string            { return proto.CompactTextString(m) }
func (*ConsensusResponse) ProtoMessage()               {}
func (*ConsensusResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{16} }

// ******* Node Metadata *********
type Metadata struct {
	Metadata map[string][]byte `protobuf:"bytes,1,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{17} }

func (m *Metadata) GetMetadata() map[string][]byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type ProbeMessage struct {
	Sender  *Endpoint `protobuf:"bytes,1,opt,name=sender" json:"sender,omitempty"`
	Payload [][]byte  `protobuf:"bytes,3,rep,name=payload" json:"payload,omitempty"`
}

func (m *ProbeMessage) Reset()                    { *m = ProbeMessage{} }
func (m *ProbeMessage) String() string            { return proto.CompactTextString(m) }
func (*ProbeMessage) ProtoMessage()               {}
func (*ProbeMessage) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{18} }

func (m *ProbeMessage) GetSender() *Endpoint {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *ProbeMessage) GetPayload() [][]byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ProbeResponse struct {
	Status NodeStatus `protobuf:"varint,1,opt,name=status,proto3,enum=remoting.NodeStatus" json:"status,omitempty"`
}

func (m *ProbeResponse) Reset()                    { *m = ProbeResponse{} }
func (m *ProbeResponse) String() string            { return proto.CompactTextString(m) }
func (*ProbeResponse) ProtoMessage()               {}
func (*ProbeResponse) Descriptor() ([]byte, []int) { return fileDescriptorRapid, []int{19} }

func (m *ProbeResponse) GetStatus() NodeStatus {
	if m != nil {
		return m.Status
	}
	return NodeStatus_OK
}

func init() {
	proto.RegisterType((*Endpoint)(nil), "remoting.Endpoint")
	proto.RegisterType((*RapidRequest)(nil), "remoting.RapidRequest")
	proto.RegisterType((*RapidResponse)(nil), "remoting.RapidResponse")
	proto.RegisterType((*NodeId)(nil), "remoting.NodeId")
	proto.RegisterType((*PreJoinMessage)(nil), "remoting.PreJoinMessage")
	proto.RegisterType((*JoinMessage)(nil), "remoting.JoinMessage")
	proto.RegisterType((*JoinResponse)(nil), "remoting.JoinResponse")
	proto.RegisterType((*BatchedLinkUpdateMessage)(nil), "remoting.BatchedLinkUpdateMessage")
	proto.RegisterType((*LinkUpdateMessage)(nil), "remoting.LinkUpdateMessage")
	proto.RegisterType((*Response)(nil), "remoting.Response")
	proto.RegisterType((*FastRoundPhase2BMessage)(nil), "remoting.FastRoundPhase2bMessage")
	proto.RegisterType((*Rank)(nil), "remoting.Rank")
	proto.RegisterType((*Phase1AMessage)(nil), "remoting.Phase1aMessage")
	proto.RegisterType((*Phase1BMessage)(nil), "remoting.Phase1bMessage")
	proto.RegisterType((*Phase2AMessage)(nil), "remoting.Phase2aMessage")
	proto.RegisterType((*Phase2BMessage)(nil), "remoting.Phase2bMessage")
	proto.RegisterType((*ConsensusResponse)(nil), "remoting.ConsensusResponse")
	proto.RegisterType((*Metadata)(nil), "remoting.Metadata")
	proto.RegisterType((*ProbeMessage)(nil), "remoting.ProbeMessage")
	proto.RegisterType((*ProbeResponse)(nil), "remoting.ProbeResponse")
	proto.RegisterEnum("remoting.JoinStatusCode", JoinStatusCode_name, JoinStatusCode_value)
	proto.RegisterEnum("remoting.LinkStatus", LinkStatus_name, LinkStatus_value)
	proto.RegisterEnum("remoting.NodeStatus", NodeStatus_name, NodeStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MembershipService service

type MembershipServiceClient interface {
	SendRequest(ctx context.Context, in *RapidRequest, opts ...grpc.CallOption) (*RapidResponse, error)
}

type membershipServiceClient struct {
	cc *grpc.ClientConn
}

func NewMembershipServiceClient(cc *grpc.ClientConn) MembershipServiceClient {
	return &membershipServiceClient{cc}
}

func (c *membershipServiceClient) SendRequest(ctx context.Context, in *RapidRequest, opts ...grpc.CallOption) (*RapidResponse, error) {
	out := new(RapidResponse)
	err := grpc.Invoke(ctx, "/remoting.MembershipService/sendRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MembershipService service

type MembershipServiceServer interface {
	SendRequest(context.Context, *RapidRequest) (*RapidResponse, error)
}

func RegisterMembershipServiceServer(s *grpc.Server, srv MembershipServiceServer) {
	s.RegisterService(&_MembershipService_serviceDesc, srv)
}

func _MembershipService_SendRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RapidRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MembershipServiceServer).SendRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/remoting.MembershipService/SendRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MembershipServiceServer).SendRequest(ctx, req.(*RapidRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MembershipService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "remoting.MembershipService",
	HandlerType: (*MembershipServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "sendRequest",
			Handler:    _MembershipService_SendRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rapid.proto",
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Port))
	}
	return i, nil
}

func (m *RapidRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RapidRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		nn1, err := m.Content.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *RapidRequest_PreJoinMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreJoinMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.PreJoinMessage.Size()))
		n2, err := m.PreJoinMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *RapidRequest_JoinMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JoinMessage != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.JoinMessage.Size()))
		n3, err := m.JoinMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *RapidRequest_BatchedLinkUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.BatchedLinkUpdateMessage != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.BatchedLinkUpdateMessage.Size()))
		n4, err := m.BatchedLinkUpdateMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *RapidRequest_ProbeMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ProbeMessage != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ProbeMessage.Size()))
		n5, err := m.ProbeMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *RapidRequest_FastRoundPhase2BMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.FastRoundPhase2BMessage != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.FastRoundPhase2BMessage.Size()))
		n6, err := m.FastRoundPhase2BMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *RapidRequest_Phase1AMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Phase1AMessage != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Phase1AMessage.Size()))
		n7, err := m.Phase1AMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *RapidRequest_Phase1BMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Phase1BMessage != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Phase1BMessage.Size()))
		n8, err := m.Phase1BMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *RapidRequest_Phase2AMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Phase2AMessage != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Phase2AMessage.Size()))
		n9, err := m.Phase2AMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *RapidRequest_Phase2BMessage) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Phase2BMessage != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Phase2BMessage.Size()))
		n10, err := m.Phase2BMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *RapidResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RapidResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Content != nil {
		nn11, err := m.Content.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	return i, nil
}

func (m *RapidResponse_JoinResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.JoinResponse != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.JoinResponse.Size()))
		n12, err := m.JoinResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *RapidResponse_Response) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Response != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Response.Size()))
		n13, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *RapidResponse_ConsensusResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ConsensusResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConsensusResponse.Size()))
		n14, err := m.ConsensusResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *RapidResponse_ProbeResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ProbeResponse != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ProbeResponse.Size()))
		n15, err := m.ProbeResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *NodeId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.High != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.High))
	}
	if m.Low != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Low))
	}
	return i, nil
}

func (m *PreJoinMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreJoinMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n16, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.NodeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n17, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.RingNumber) > 0 {
		dAtA19 := make([]byte, len(m.RingNumber)*10)
		var j18 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	return i, nil
}

func (m *JoinMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n20, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.NodeId != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n21, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.RingNumber) > 0 {
		dAtA23 := make([]byte, len(m.RingNumber)*10)
		var j22 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Metadata.Size()))
		n24, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *JoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JoinResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n25, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.StatusCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.StatusCode))
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.Endpoints) > 0 {
		for _, msg := range m.Endpoints {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Identifiers) > 0 {
		for _, msg := range m.Identifiers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterMetadata) > 0 {
		for k, _ := range m.ClusterMetadata {
			dAtA[i] = 0x32
			i++
			v := m.ClusterMetadata[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRapid(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovRapid(uint64(len(k))) + msgSize
			i = encodeVarintRapid(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRapid(dAtA, i, uint64(v.Size()))
				n26, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n26
			}
		}
	}
	return i, nil
}

func (m *BatchedLinkUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchedLinkUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n27, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LinkUpdateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkUpdateMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LinkSrc != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.LinkSrc.Size()))
		n28, err := m.LinkSrc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.LinkDst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.LinkDst.Size()))
		n29, err := m.LinkDst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.LinkStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.LinkStatus))
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.RingNumber) > 0 {
		dAtA31 := make([]byte, len(m.RingNumber)*10)
		var j30 int
		for _, num1 := range m.RingNumber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if m.NodeId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeId.Size()))
		n32, err := m.NodeId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Metadata != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Metadata.Size()))
		n33, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FastRoundPhase2BMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FastRoundPhase2BMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n34, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if len(m.Endpoints) > 0 {
		for _, msg := range m.Endpoints {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Rank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rank) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Round != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Round))
	}
	if m.NodeIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.NodeIndex))
	}
	return i, nil
}

func (m *Phase1AMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Phase1AMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n35, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Rank != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Rank.Size()))
		n36, err := m.Rank.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *Phase1BMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Phase1BMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n37, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Rnd.Size()))
		n38, err := m.Rnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Vrnd != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Vrnd.Size()))
		n39, err := m.Vrnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if len(m.Vval) > 0 {
		for _, msg := range m.Vval {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Phase2AMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Phase2AMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n40, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Rnd.Size()))
		n41, err := m.Rnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Vval) > 0 {
		for _, msg := range m.Vval {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Phase2BMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Phase2BMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n42, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.ConfigurationId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Rnd.Size()))
		n43, err := m.Rnd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Endpoints) > 0 {
		for _, msg := range m.Endpoints {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRapid(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ConsensusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0xa
			i++
			v := m.Metadata[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovRapid(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovRapid(uint64(len(k))) + byteSize
			i = encodeVarintRapid(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRapid(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *ProbeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sender != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Sender.Size()))
		n44, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRapid(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *ProbeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRapid(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func encodeFixed64Rapid(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Rapid(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRapid(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Endpoint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovRapid(uint64(m.Port))
	}
	return n
}

func (m *RapidRequest) Size() (n int) {
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *RapidRequest_PreJoinMessage) Size() (n int) {
	var l int
	_ = l
	if m.PreJoinMessage != nil {
		l = m.PreJoinMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_JoinMessage) Size() (n int) {
	var l int
	_ = l
	if m.JoinMessage != nil {
		l = m.JoinMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_BatchedLinkUpdateMessage) Size() (n int) {
	var l int
	_ = l
	if m.BatchedLinkUpdateMessage != nil {
		l = m.BatchedLinkUpdateMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_ProbeMessage) Size() (n int) {
	var l int
	_ = l
	if m.ProbeMessage != nil {
		l = m.ProbeMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_FastRoundPhase2BMessage) Size() (n int) {
	var l int
	_ = l
	if m.FastRoundPhase2BMessage != nil {
		l = m.FastRoundPhase2BMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_Phase1AMessage) Size() (n int) {
	var l int
	_ = l
	if m.Phase1AMessage != nil {
		l = m.Phase1AMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_Phase1BMessage) Size() (n int) {
	var l int
	_ = l
	if m.Phase1BMessage != nil {
		l = m.Phase1BMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_Phase2AMessage) Size() (n int) {
	var l int
	_ = l
	if m.Phase2AMessage != nil {
		l = m.Phase2AMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidRequest_Phase2BMessage) Size() (n int) {
	var l int
	_ = l
	if m.Phase2BMessage != nil {
		l = m.Phase2BMessage.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidResponse) Size() (n int) {
	var l int
	_ = l
	if m.Content != nil {
		n += m.Content.Size()
	}
	return n
}

func (m *RapidResponse_JoinResponse) Size() (n int) {
	var l int
	_ = l
	if m.JoinResponse != nil {
		l = m.JoinResponse.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidResponse_Response) Size() (n int) {
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidResponse_ConsensusResponse) Size() (n int) {
	var l int
	_ = l
	if m.ConsensusResponse != nil {
		l = m.ConsensusResponse.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *RapidResponse_ProbeResponse) Size() (n int) {
	var l int
	_ = l
	if m.ProbeResponse != nil {
		l = m.ProbeResponse.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}
func (m *NodeId) Size() (n int) {
	var l int
	_ = l
	if m.High != 0 {
		n += 1 + sovRapid(uint64(m.High))
	}
	if m.Low != 0 {
		n += 1 + sovRapid(uint64(m.Low))
	}
	return n
}

func (m *PreJoinMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	return n
}

func (m *JoinMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}

func (m *JoinResponse) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.StatusCode != 0 {
		n += 1 + sovRapid(uint64(m.StatusCode))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	if len(m.Identifiers) > 0 {
		for _, e := range m.Identifiers {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	if len(m.ClusterMetadata) > 0 {
		for k, v := range m.ClusterMetadata {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRapid(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovRapid(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRapid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BatchedLinkUpdateMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *LinkUpdateMessage) Size() (n int) {
	var l int
	_ = l
	if m.LinkSrc != nil {
		l = m.LinkSrc.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.LinkDst != nil {
		l = m.LinkDst.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.LinkStatus != 0 {
		n += 1 + sovRapid(uint64(m.LinkStatus))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.RingNumber) > 0 {
		l = 0
		for _, e := range m.RingNumber {
			l += sovRapid(uint64(e))
		}
		n += 1 + sovRapid(uint64(l)) + l
	}
	if m.NodeId != nil {
		l = m.NodeId.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FastRoundPhase2BMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *Rank) Size() (n int) {
	var l int
	_ = l
	if m.Round != 0 {
		n += 1 + sovRapid(uint64(m.Round))
	}
	if m.NodeIndex != 0 {
		n += 1 + sovRapid(uint64(m.NodeIndex))
	}
	return n
}

func (m *Phase1AMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Rank != nil {
		l = m.Rank.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	return n
}

func (m *Phase1BMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		l = m.Rnd.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.Vrnd != nil {
		l = m.Vrnd.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Vval) > 0 {
		for _, e := range m.Vval {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *Phase2AMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		l = m.Rnd.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Vval) > 0 {
		for _, e := range m.Vval {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *Phase2BMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if m.ConfigurationId != 0 {
		n += 1 + sovRapid(uint64(m.ConfigurationId))
	}
	if m.Rnd != nil {
		l = m.Rnd.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Endpoints) > 0 {
		for _, e := range m.Endpoints {
			l = e.Size()
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *ConsensusResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovRapid(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovRapid(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRapid(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ProbeMessage) Size() (n int) {
	var l int
	_ = l
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovRapid(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			l = len(b)
			n += 1 + l + sovRapid(uint64(l))
		}
	}
	return n
}

func (m *ProbeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRapid(uint64(m.Status))
	}
	return n
}

func sovRapid(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRapid(x uint64) (n int) {
	return sovRapid(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RapidRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RapidRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RapidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreJoinMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreJoinMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_PreJoinMessage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JoinMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_JoinMessage{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchedLinkUpdateMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BatchedLinkUpdateMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_BatchedLinkUpdateMessage{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProbeMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_ProbeMessage{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FastRoundPhase2BMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FastRoundPhase2BMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_FastRoundPhase2BMessage{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase1AMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Phase1AMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_Phase1AMessage{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase1BMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Phase1BMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_Phase1BMessage{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase2AMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Phase2AMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_Phase2AMessage{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase2BMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Phase2BMessage{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidRequest_Phase2BMessage{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RapidResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RapidResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RapidResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &JoinResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidResponse_JoinResponse{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Response{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidResponse_Response{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsensusResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsensusResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidResponse_ConsensusResponse{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProbeResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProbeResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Content = &RapidResponse_ProbeResponse{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			m.High = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.High |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			m.Low = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Low |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreJoinMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreJoinMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreJoinMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= (JoinStatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &Endpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifiers = append(m.Identifiers, &NodeId{})
			if err := m.Identifiers[len(m.Identifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthRapid
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ClusterMetadata == nil {
				m.ClusterMetadata = make(map[string]*Metadata)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthRapid
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthRapid
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Metadata{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ClusterMetadata[mapkey] = mapvalue
			} else {
				var mapvalue *Metadata
				m.ClusterMetadata[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchedLinkUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchedLinkUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchedLinkUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &LinkUpdateMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkUpdateMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkUpdateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkUpdateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkSrc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkSrc == nil {
				m.LinkSrc = &Endpoint{}
			}
			if err := m.LinkSrc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkDst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LinkDst == nil {
				m.LinkDst = &Endpoint{}
			}
			if err := m.LinkDst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkStatus", wireType)
			}
			m.LinkStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinkStatus |= (LinkStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RingNumber = append(m.RingNumber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRapid
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRapid
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RingNumber = append(m.RingNumber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RingNumber", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeId == nil {
				m.NodeId = &NodeId{}
			}
			if err := m.NodeId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FastRoundPhase2BMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastRoundPhase2bMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastRoundPhase2bMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &Endpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeIndex", wireType)
			}
			m.NodeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Phase1AMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Phase1aMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Phase1aMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rank == nil {
				m.Rank = &Rank{}
			}
			if err := m.Rank.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Phase1BMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Phase1bMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Phase1bMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rnd == nil {
				m.Rnd = &Rank{}
			}
			if err := m.Rnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vrnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vrnd == nil {
				m.Vrnd = &Rank{}
			}
			if err := m.Vrnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vval = append(m.Vval, &Endpoint{})
			if err := m.Vval[len(m.Vval)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Phase2AMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Phase2aMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Phase2aMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rnd == nil {
				m.Rnd = &Rank{}
			}
			if err := m.Rnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vval = append(m.Vval, &Endpoint{})
			if err := m.Vval[len(m.Vval)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Phase2BMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Phase2bMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Phase2bMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationId", wireType)
			}
			m.ConfigurationId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rnd == nil {
				m.Rnd = &Rank{}
			}
			if err := m.Rnd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoints = append(m.Endpoints, &Endpoint{})
			if err := m.Endpoints[len(m.Endpoints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthRapid
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Metadata == nil {
				m.Metadata = make(map[string][]byte)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapbyteLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapbyteLen |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intMapbyteLen := int(mapbyteLen)
				if intMapbyteLen < 0 {
					return ErrInvalidLengthRapid
				}
				postbytesIndex := iNdEx + intMapbyteLen
				if postbytesIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := make([]byte, mapbyteLen)
				copy(mapvalue, dAtA[iNdEx:postbytesIndex])
				iNdEx = postbytesIndex
				m.Metadata[mapkey] = mapvalue
			} else {
				var mapvalue []byte
				m.Metadata[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Endpoint{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRapid
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, make([]byte, postIndex-iNdEx))
			copy(m.Payload[len(m.Payload)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (NodeStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRapid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRapid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRapid(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRapid
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRapid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRapid
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRapid
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRapid(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRapid = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRapid   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rapid.proto", fileDescriptorRapid) }

var fileDescriptorRapid = []byte{
	// 1229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0x4d, 0x6f, 0xe3, 0x54,
	0x17, 0x8e, 0xe3, 0x24, 0x4d, 0x4f, 0xd2, 0x4c, 0x7a, 0xa7, 0xef, 0xd4, 0xea, 0x3b, 0xaa, 0x82,
	0x17, 0x10, 0x95, 0x51, 0x34, 0x04, 0x24, 0x86, 0x32, 0x08, 0xf2, 0xd5, 0x26, 0x9d, 0xc9, 0x87,
	0x6e, 0x12, 0x10, 0x0b, 0x14, 0x9c, 0xf8, 0x36, 0x31, 0x49, 0xaf, 0x83, 0xed, 0x04, 0xba, 0x62,
	0x85, 0x90, 0xf8, 0x05, 0x6c, 0x59, 0xb1, 0x45, 0x62, 0xc7, 0x2f, 0x80, 0x1d, 0x0b, 0xb6, 0x48,
	0xa8, 0xbf, 0x04, 0xf9, 0xfa, 0xbb, 0x76, 0x98, 0x66, 0x31, 0x1a, 0xb1, 0xb3, 0xef, 0x79, 0xce,
	0x73, 0x9f, 0x7b, 0x7c, 0x3e, 0xae, 0x21, 0xa3, 0x49, 0x4b, 0x45, 0x2e, 0x2d, 0x35, 0xd5, 0x50,
	0x51, 0x5a, 0x23, 0x57, 0xaa, 0xa1, 0xd0, 0xa9, 0x78, 0x0a, 0xe9, 0x06, 0x95, 0x97, 0xaa, 0x42,
	0x0d, 0x74, 0x04, 0xe9, 0x99, 0xaa, 0x1b, 0x54, 0xba, 0x22, 0x02, 0x57, 0xe0, 0x8a, 0xbb, 0xd8,
	0x7d, 0x47, 0x08, 0x12, 0x4b, 0x55, 0x33, 0x84, 0x78, 0x81, 0x2b, 0x26, 0x31, 0x7b, 0x16, 0x7f,
	0x4a, 0x42, 0x16, 0x9b, 0xac, 0x98, 0x7c, 0xb9, 0x22, 0xba, 0x81, 0xaa, 0x90, 0x5b, 0x6a, 0xe4,
	0x42, 0x55, 0x68, 0x9b, 0xe8, 0xba, 0x34, 0xb5, 0x68, 0x32, 0x65, 0xa1, 0xe4, 0xec, 0x57, 0xea,
	0x05, 0xec, 0xcd, 0x18, 0xbe, 0xe5, 0x81, 0xde, 0x83, 0xcc, 0x17, 0x3e, 0x82, 0x38, 0x23, 0xf8,
	0x9f, 0x47, 0x10, 0xf4, 0xf6, 0x63, 0xd1, 0xe7, 0x20, 0x8c, 0x25, 0x63, 0x32, 0x23, 0xf2, 0x73,
	0x85, 0xce, 0x87, 0x4b, 0x59, 0x32, 0x88, 0xc3, 0xc3, 0x33, 0x1e, 0xd1, 0xe3, 0xa9, 0x6e, 0x40,
	0x36, 0x63, 0x78, 0x23, 0x0b, 0x7a, 0x0a, 0xd9, 0xa5, 0xa6, 0x8e, 0x5d, 0xd6, 0x04, 0x63, 0x7d,
	0xe0, 0x3f, 0x9e, 0x67, 0x6d, 0xc6, 0x70, 0x00, 0x8d, 0x3e, 0x83, 0xc3, 0x4b, 0x49, 0x37, 0xb0,
	0xba, 0xa2, 0x72, 0x6f, 0x26, 0xe9, 0xa4, 0x3c, 0x76, 0x88, 0x92, 0x8c, 0xe8, 0x35, 0x8f, 0xe8,
	0x2c, 0x1a, 0xd8, 0x8c, 0xe1, 0x4d, 0x1c, 0x2c, 0xfa, 0xe6, 0xca, 0x5b, 0x92, 0xc3, 0x9a, 0x0a,
	0x45, 0x3f, 0x60, 0x67, 0xd1, 0x0f, 0xac, 0x78, 0x1c, 0xae, 0xb2, 0x9d, 0x68, 0x8e, 0x71, 0x88,
	0x23, 0xa4, 0xa3, 0xec, 0xea, 0x48, 0x47, 0x72, 0x94, 0x43, 0x3a, 0xca, 0x21, 0x1d, 0x5e, 0x84,
	0x76, 0xa3, 0x39, 0x42, 0x3a, 0xdc, 0x95, 0xea, 0x2e, 0xec, 0x4c, 0x54, 0x6a, 0x10, 0x6a, 0x88,
	0x3f, 0xc4, 0x61, 0xcf, 0xce, 0x54, 0x7d, 0xa9, 0x52, 0x9d, 0x7d, 0x49, 0x33, 0x75, 0x9c, 0x77,
	0x3b, 0x51, 0x1f, 0x04, 0xf3, 0xcc, 0xb1, 0x9a, 0x5f, 0xd2, 0x8f, 0x46, 0x8f, 0x21, 0xad, 0x39,
	0x9e, 0x56, 0x86, 0x22, 0xcf, 0xd3, 0xe7, 0xe5, 0xa2, 0xd0, 0x33, 0xd8, 0x9f, 0x98, 0x0f, 0x54,
	0x5f, 0xe9, 0xee, 0xa6, 0x56, 0x52, 0xfe, 0xdf, 0x73, 0xad, 0xdd, 0x86, 0x34, 0x63, 0x38, 0xec,
	0x87, 0x3e, 0x84, 0x3d, 0x96, 0x58, 0x2e, 0x91, 0x95, 0x87, 0x87, 0xb7, 0xf2, 0xd0, 0x47, 0x12,
	0xc4, 0xfb, 0x43, 0x53, 0x82, 0x54, 0x47, 0x95, 0x49, 0x4b, 0x36, 0x4b, 0x7c, 0xa6, 0x4c, 0x67,
	0x2c, 0x14, 0x3c, 0x66, 0xcf, 0x28, 0x0f, 0xfc, 0x42, 0xfd, 0x8a, 0x9d, 0x91, 0xc7, 0xe6, 0xa3,
	0xf8, 0x33, 0x07, 0xb9, 0x60, 0x11, 0xa3, 0x13, 0x48, 0xe9, 0x84, 0xca, 0x44, 0xb3, 0xa3, 0xe8,
	0x8b, 0x85, 0xd3, 0x5b, 0xb0, 0x8d, 0x40, 0x45, 0x48, 0x51, 0xb6, 0x9d, 0x1d, 0xb7, 0xbc, 0x87,
	0xb5, 0x64, 0x60, 0xdb, 0x8e, 0x8e, 0x01, 0x34, 0x85, 0x4e, 0x3b, 0xab, 0xab, 0x31, 0xd1, 0x04,
	0xbe, 0xc0, 0x17, 0x93, 0xd8, 0xb7, 0x82, 0x8a, 0x70, 0x6f, 0xa2, 0xd2, 0x4b, 0x65, 0xba, 0xd2,
	0x24, 0x43, 0x51, 0x69, 0x4b, 0x66, 0x61, 0xe0, 0xf1, 0xed, 0x65, 0xf1, 0x2f, 0x0e, 0x32, 0xff,
	0x21, 0xbd, 0xa8, 0x04, 0xe9, 0x2b, 0x62, 0x48, 0xb2, 0x64, 0x48, 0x76, 0x63, 0xf0, 0x29, 0x6c,
	0xdb, 0x16, 0xec, 0x62, 0xc4, 0x5f, 0x78, 0xc8, 0xfa, 0xd3, 0x75, 0xab, 0x03, 0x3e, 0x01, 0xd0,
	0x0d, 0xc9, 0x58, 0xe9, 0x35, 0x55, 0xb6, 0x92, 0x39, 0xe7, 0xaf, 0x32, 0x93, 0xb7, 0xef, 0xda,
	0xb1, 0x0f, 0x1b, 0x75, 0x20, 0x3e, 0xfa, 0x40, 0x8f, 0x61, 0x97, 0xd8, 0xfb, 0xea, 0x42, 0xa2,
	0xc0, 0x6f, 0x90, 0xe4, 0x81, 0x50, 0x19, 0x32, 0x8a, 0x4c, 0xa8, 0xa1, 0x5c, 0x2a, 0x44, 0xd3,
	0x85, 0x24, 0xf3, 0x09, 0xc7, 0xde, 0x0f, 0x42, 0x43, 0xb8, 0x37, 0x59, 0xac, 0x74, 0x83, 0x68,
	0x4e, 0x8c, 0x84, 0x14, 0xf3, 0x7b, 0x33, 0xba, 0xaa, 0x4b, 0xb5, 0x20, 0xba, 0x41, 0x0d, 0xed,
	0x1a, 0xdf, 0xe6, 0x38, 0xfa, 0x18, 0x0e, 0xa2, 0x80, 0x66, 0x69, 0xcc, 0xc9, 0xb5, 0x3d, 0x28,
	0xcd, 0x47, 0x54, 0x84, 0xe4, 0x5a, 0x5a, 0xac, 0x22, 0x5a, 0x82, 0xfb, 0xd1, 0x2c, 0xc0, 0x69,
	0xfc, 0x09, 0x27, 0x7e, 0x03, 0xc2, 0xa6, 0x19, 0xb4, 0xd5, 0x07, 0x7c, 0xd7, 0xcc, 0x16, 0xe6,
	0xa6, 0xb3, 0xac, 0x0b, 0x34, 0x94, 0x10, 0x35, 0x76, 0xc1, 0xe2, 0xef, 0x71, 0xd8, 0x0f, 0x6f,
	0xfd, 0x08, 0x76, 0x16, 0x0a, 0x9d, 0xf7, 0xb5, 0xc9, 0xbf, 0xec, 0xed, 0x40, 0x1c, 0x74, 0x5d,
	0x37, 0xc2, 0x87, 0x0e, 0xa2, 0xeb, 0xba, 0x81, 0xde, 0x01, 0x60, 0x8e, 0x2c, 0x87, 0x58, 0xb2,
	0xe4, 0xca, 0x07, 0x41, 0xb1, 0x96, 0x0d, 0xfb, 0x70, 0x5b, 0x14, 0x4e, 0xb0, 0x04, 0x93, 0x11,
	0x25, 0xe8, 0x14, 0x73, 0xea, 0x05, 0xc5, 0xec, 0x2f, 0xc1, 0x9d, 0x3b, 0x94, 0x20, 0x40, 0xda,
	0x49, 0x2b, 0xf1, 0x47, 0x0e, 0x0e, 0x37, 0x8c, 0xef, 0x2d, 0x5b, 0x4f, 0xe8, 0xdc, 0xf1, 0x3b,
	0xd4, 0x17, 0x7f, 0x87, 0xfa, 0x12, 0x4f, 0x21, 0x81, 0x25, 0x3a, 0x47, 0x07, 0x90, 0xd4, 0x4c,
	0x99, 0x4c, 0x4e, 0x12, 0x5b, 0x2f, 0xe8, 0x21, 0xec, 0xb2, 0x38, 0x50, 0x99, 0x7c, 0x6d, 0xdf,
	0xf8, 0xbc, 0x05, 0xf1, 0x7b, 0x73, 0x02, 0x04, 0xaf, 0x0d, 0x2f, 0xe7, 0x58, 0x22, 0x24, 0x34,
	0x89, 0xce, 0xed, 0x31, 0x99, 0xf3, 0x4d, 0x58, 0x89, 0xce, 0x31, 0xb3, 0x89, 0x7f, 0xba, 0x62,
	0x5e, 0x72, 0x8c, 0x0b, 0xc0, 0x6b, 0x54, 0xde, 0xa0, 0xc5, 0x34, 0x99, 0x72, 0xd7, 0x26, 0x24,
	0x11, 0x2d, 0xd7, 0xb4, 0xa1, 0xd7, 0x21, 0xb1, 0x5e, 0x4b, 0x0b, 0xbb, 0xa1, 0x45, 0x29, 0x63,
	0x76, 0x6b, 0xca, 0x06, 0xaf, 0x44, 0xaf, 0xea, 0x58, 0x77, 0x95, 0xfc, 0xab, 0x2b, 0xf9, 0x95,
	0x7f, 0x89, 0xad, 0xe7, 0x8d, 0x78, 0x1f, 0xf6, 0x43, 0x77, 0x2f, 0xf1, 0x5b, 0x0e, 0xd2, 0x4e,
	0xad, 0xa3, 0xa7, 0xbe, 0x8e, 0xc0, 0x31, 0xca, 0x42, 0xb8, 0x23, 0x94, 0x82, 0xb3, 0xc4, 0xf5,
	0x38, 0x7a, 0x1f, 0xf6, 0x5e, 0x34, 0x3d, 0x0e, 0xfc, 0xd3, 0x23, 0xeb, 0x9f, 0x14, 0x03, 0xc8,
	0xfa, 0xff, 0x2b, 0xb6, 0x0a, 0xab, 0x00, 0x3b, 0x4b, 0xe9, 0x7a, 0xa1, 0x4a, 0x32, 0x6b, 0x0c,
	0x59, 0xec, 0xbc, 0x8a, 0x1f, 0xc0, 0x5e, 0xe0, 0x96, 0x88, 0x1e, 0x41, 0xca, 0x9a, 0xee, 0x8c,
	0x36, 0xd0, 0x99, 0xcd, 0xee, 0x68, 0x77, 0x66, 0x1b, 0x73, 0xf2, 0x1d, 0x07, 0xb9, 0xe0, 0xe5,
	0x00, 0x3d, 0x04, 0xa1, 0xd9, 0xed, 0x0f, 0x3a, 0x95, 0x76, 0x63, 0x54, 0x79, 0x8e, 0x1b, 0x95,
	0xfa, 0xa7, 0xa3, 0x56, 0x67, 0x84, 0x5b, 0x9d, 0xf3, 0x7c, 0x0c, 0x09, 0x70, 0x30, 0x1c, 0xb6,
	0xea, 0x21, 0x0b, 0x87, 0xf2, 0x90, 0xed, 0x57, 0xce, 0x1a, 0xa3, 0x41, 0x77, 0x74, 0xd1, 0x6d,
	0x75, 0xf2, 0x71, 0x84, 0x20, 0x57, 0xeb, 0x76, 0xce, 0x5a, 0xe7, 0xa3, 0x5a, 0xb3, 0xd2, 0x39,
	0x6f, 0xd4, 0xf3, 0x3c, 0x3a, 0x84, 0xfb, 0xed, 0x46, 0xbb, 0xda, 0xc0, 0xfd, 0x66, 0xab, 0x37,
	0xc2, 0x8d, 0x8b, 0x46, 0x6d, 0xd0, 0xa8, 0xe7, 0x13, 0x27, 0xc7, 0x00, 0xde, 0xe4, 0x40, 0x29,
	0x88, 0x0f, 0x7b, 0xf9, 0x18, 0x4a, 0x43, 0xa2, 0xde, 0xfd, 0xa4, 0x93, 0xe7, 0x4e, 0xde, 0x00,
	0xf0, 0xf4, 0x9b, 0xf6, 0xee, 0xb3, 0x7c, 0x0c, 0xed, 0xc3, 0x5e, 0xb5, 0xdb, 0x1d, 0xf4, 0x07,
	0xb8, 0xd2, 0xeb, 0x31, 0x1d, 0xe5, 0x21, 0xec, 0xb7, 0x89, 0x39, 0x28, 0xf4, 0x99, 0xb2, 0xec,
	0x13, 0x6d, 0xad, 0x4c, 0x08, 0xfa, 0x08, 0x32, 0x66, 0x28, 0x9d, 0x5f, 0xdc, 0x07, 0xfe, 0x7c,
	0xf3, 0x7e, 0x7d, 0x8f, 0x0e, 0x43, 0xeb, 0x76, 0x12, 0xc5, 0xaa, 0x27, 0xbf, 0xdd, 0x1c, 0x73,
	0x7f, 0xdc, 0x1c, 0x73, 0x7f, 0xdf, 0x1c, 0x73, 0x90, 0x9f, 0xa8, 0x57, 0xa5, 0xb5, 0x36, 0x2d,
	0xd9, 0xff, 0xe3, 0xe3, 0x6a, 0x1a, 0xdb, 0x9e, 0x3d, 0x6e, 0x9c, 0x62, 0xff, 0xe7, 0x6f, 0xff,
	0x13, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x64, 0xee, 0x84, 0xae, 0x0f, 0x00, 0x00,
}
